previous: D:\Media\Workshop\DOCS\Notes\Степан_20160302_010918.note

escape from butcher bay
SOMA
apkmirror
Guillermo del Toro
Alejandro Jodorowsky
https://www.twitch.tv/bethesda/v/82135695
https://www.twitch.tv/bethesda/v/82139751
https://www.twitch.tv/bethesda/v/82144251

I. Генерация имен для содержимого EntMan:
  1. Хранить ссылку на имя класса внутри каждой энтити: будет полезно для генерализации
	а. Идея: хранить имя класса внутри имени энтити, например, таким образом:
	    name: "CustomEnt", class: "info_null", man_name: "CustomEnt##info_null"
	b. Простой вариант: внутри Entity сделать указатель на string; при создании энтити адрес строки имени класса из генератора помещается в этот указатель.
	c. Можно хранить указатель не просто на имя класса, но непосредственно на EntityMaker. Пригодится для обращения к таблице параметров при заполнении полей энтити и содержимого окна менеджера
  2. Сейчас для конструктор энтити при генерации использует classname. Это полезно, поскольку позволяет немедленно удалять некорректно сгенерированные листы. Однако, в таком случае 
	a. В ходе обработки энтити задавать имя самым последним шагом: если в описании энтити встретился тег "$name" - изменить имя энтити на это имя, иначе - сгенерировать произвольное имя на основе, например, числа уже добавленных энтитей.
	В таком случае, для изменения имени энтити будет достаточно функции вида Manager::ChangeName(oldName, newName), где oldName == classname, newName = entity_name
	
	Для загрузки материалов/моделей/прочих файлов использовать единый тип поля FIELD_FILE и функцию, которая определяет тип файла и загружает его в соответствующий менеджер
	!Материалы не являются файлами!
	
	enum типов полей можно также использовать для типов cvar.
	Все функции, особенно функции отрисовки окон, должны по возможности работать с cvar напрямую (без обращения в cvar manager)
	
	Для ambient освещения использовать отдельный параметр/энтитю вместо самостоятельных параметров у каждого источника освещения
	
II. Шейдеры и материалы
	В Source используемый для отрисовки объекта шейдер задается внутри материала.
	Все источники освещения должны храниться в отдельном дереве, ИЛИ особым образом помеченны, чтобы их было просто найти.
	Всякий раз при переключении шейдера в него должны загружаться параметры активных источников света.
	В Source параметры шейдеров прописываются внутри кода игры.
	
III. Порядок отрисовки кадра:
		1. Определить активный сектор.
		2. Отрисовать геометрию сектора:
			а. Определить все видимые поверхности внутри сектора. Добавить в список отрисовываемых поверхностей.
			б. Определить все видимые порталы.
			в. Добавить все видимые через порталы поверхности в список.
			г. Отсортировать список: сгруппировать все поверхности с одинаковыми материалами; после этого сгруппировать вместе группы материалов, использующие одинаковые шейдеры.
			д. Отрисовать все поверхности в списке по порядку.
			е. ОТРИСОВКА ПОВЕРХНОСТЕЙ:
				Каждая поверхность представлена набором из трех (четырех?) вершин. 
				 Для каждой вершины должна быть представлена координата, нормаль и текстурный вектор.
				 Разные поверхности могут использовать для своих вершин одинаковые наборы координат.
				 Нормали у всех вершин плоской поверхности должны быть одинаковы. Направление перпендикулярной нормали можно хранить в порядке объявления вершин.
				 Текстурный вектор должен вычисляться процедурно на основе параметров сдвига текстуры на поверхности.
				Таким образом, параметры всех вершин могут храниться в отдельном списке и вызываться поверхностями через порядковые номера.
		3. Отрисовать 3d-объекты внутри сектора
			а. Составить список видимых объектов.
			б. Отсортировать список: сначала сгруппировать объекты, использующие одинаковые модели, потом - одинаковые материалы
			в. Для каждого 3d-объекта внутри списка:
				i . Загрузить в активный шейдер все воздействующие на него источники света
				ii. Отрисовать объект.
		4. Пост-процессинг
		5. Интерфейс
				
	Хранить в отдельной структуре активный шейдер и забинженные модели/текстуры? Можно будет избежать излишних перебинживаний данных.
	Должны ли объекты хранить в себе указатели на загруженные файлы, или же просто их имена?
		а. Оптимален по скорости в любом случае, т.к. не требует поиска данных в менеджерах. НО, так как....
		   Если сравнивать адреса указателей, то сравнение имен не потребуется
		   
IV. Area-portals в Source
	Ареа-поратлы в Source - особые браши, позволяющие контролировать отрисовку частей карты.

V. Стоит ли хранить энтити в бинарном дереве?
	Количество энтитей в сцене может изменятся в любой момент в ходе игры. Бинарное дерево не слишком хорошо подходит для удаления его невисящих элементов.
	Связанный список прекрасно подходит для добавления/удаления элементов.
	Энтити должны быть привязаны к секторам для ускорения отбора при отрисовке, однако эта привязка не должна быть жесткой. Некоторые объекты статичны и не способны перемещаться из сектора в сектор - можно оставить привязку только для таких объектов.
	Если использовать не один, а несколько связанных списков - например, по отдельному списку для каждого сектора - то не будет проблем ни со скоростью поиска, ни с добавлением/удалением, ни с переносом объектов из списка в список (из сектора в сектор).
	Отдельный список может хранить элементы наподобие глобальных источников света/звука, которые обязательно должны быть обработаны при отрисовке нового кадра вне зависимости от текущего положения камеры.
	Можно также использовать глобальный список, содержащий все объекты сцены. Одно из его возможных предназначений - контроль за выпадением элементов из других списков. Если элемент будет удален из одного локального списка, но по какой-то причине не будет добавлен в другой, то он окажется "подвешенным в памяти" за гранью доступности циклов отрисовки. Периодически (через определенное кол-во отрисованных кадров/определенное кол-во операций переноса между списками) менеджер глобального списка будет пробегать сквозь него, находить такие выпадшие элементы и самостоятельно удалять их.
	
	Основным плюсом бинарного дерева является гораздо меньшее время, необходимое для нахождения необходимого элемента.
	Бинарный список будет серьезно проигрывать по времени поиска, если в нем отсутствует какой-либо механизм сортировки.
	 Можно разбить один единый список на несколько - например, по буквам алфавита (для названий или типов), или по типам энтитей. При этом все еще можно параллельно применять 
VI. Загрузка и прекэшинг данных
	При загрузке сцены все файлы, используемые присутствующими в сцене объектами, загружаются в память и сохраняются в специальном менеджере-связаном списке. Доступ объектов к содержимому файлов производится без поиска - напрямую через указатели на элементы.
	
ГОТОВО: Загрузка сцены из файла
	TODO: 
		1. Удалить весь код, ответственный за рендеринг псевдосцены, из main. Оставить интерфейс.
		2. Загрузка файлов. Переписать entity-менеджер по запискам.
		3. Патчи сцен - файлы, содержащие не весь контент сцены от начала и до конца, но небольшие порции контента, загружаемые в память вместе с уже имеющимся.
'+' и '-' перед именами консольных комманд включают-отключают их автоматическое исполнение каждый кадр

VII. Консоль
	Элементы консоли:
		1. Команды
		2. Переменные
		3. Макросы
	Помощь для команд и переменных! Команда 'help' для вывода помощи.
	Команда консоли имеет имя, указатель на выполняемую при вызове команды функцию и строку помощи с краткой инструкцией по использованию команды.
	Переменная консоли имеет имя, указатель на связанную с данной cvar переменную, идентификатор типа данных переменной и строку помощи с кратким описанием назначения переменной.
	Макросы имеют только имя и строку команд, на которую заменяется имя при вызове макроса.
	Для работы с консолью в менеджере данных должны быть реализованы методы поиска по шаблону с возможностью возврата массива-вектора подходящих результатов. Также нужно предусмотреть опцию возврата пустого массива вместо корня при отсутствии подходящих под шаблон элементов.
	Команда 'help' выводит некоторую информацию (например, тип данных переменной) не опираясь на содержание строки помощи. Для макроса она должна выводить содержимое макроса.
	Должна существовать команда наподобие 'seta' из idTech для сохранения нового значения переменной в файл автозагрузки.
	При обработке клавиатурных событий любая задержка должна быть сведена к минимуму. Поэтому, команда bind должна соотносить клавишу и лист менеджера команд.
	Для менеджера параметров в редакторе сцен: функция RenderEntityField определяет и отрисовывает тот виджет, который подходит для редактирования содержимого поля выбранной энтити.
	Базовые команды - bind, unbind, help, exit, echo, wait, exec
	Создание новых переменных прямо в консоли?
	Консоль - отдельный класс, существующий в единственном экземпляре у клиента. std::vector<string> Args
	Контроль повтора символов у зажатых клавиш.
	В Quake нажатие на клавишу добавляло ассоциированную с ней команду в командный буфер, содержимое которого выполняется каждый кадр.
	Компромисс: нажатие на клавишу с bind 'command' вызывает команду по адресу, а нажатие на bind 'macro' дописывает содержимое макро в буфер ???
	
VIII. Парсер файлов
	Парсингом всех типов файлов будет заведовать одна функция. Если расширение файла отличается от .scene, то парсер автоматически переключает стандартный режим считывания (и запрещает его изменение внутри файла?)
	
IX. Наследование и энтити
	Возможность задавать класс, от которого была унаследована энтитя, внутри таблицы параметров. Параметры класса-родителя будут выведены перед параметрами класса-наследника внутри редактора энтитей.